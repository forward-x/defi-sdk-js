/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export declare namespace CoreBase {
  export type LoanStruct = {
    interestPaid: BigNumberish;
    borrowTokenAddress: string;
    rolloverTimestamp: BigNumberish;
    lastSettleTimestamp: BigNumberish;
    collateralTokenAddress: string;
    borrowAmount: BigNumberish;
    collateralAmount: BigNumberish;
    owedPerDay: BigNumberish;
    minInterest: BigNumberish;
    interestOwed: BigNumberish;
  };

  export type LoanStructOutput = [
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    interestPaid: BigNumber;
    borrowTokenAddress: string;
    rolloverTimestamp: BigNumber;
    lastSettleTimestamp: BigNumber;
    collateralTokenAddress: string;
    borrowAmount: BigNumber;
    collateralAmount: BigNumber;
    owedPerDay: BigNumber;
    minInterest: BigNumber;
    interestOwed: BigNumber;
  };
}

export declare namespace PoolBase {
  export type WithdrawResultStruct = {
    principle: BigNumberish;
    tokenInterest: BigNumberish;
    forwInterest: BigNumberish;
    pTokenBurn: BigNumberish;
    atpTokenBurn: BigNumberish;
    lossBurn: BigNumberish;
    itpTokenBurn: BigNumberish;
    ifpTokenBurn: BigNumberish;
    tokenInterestBonus: BigNumberish;
    forwInterestBonus: BigNumberish;
  };

  export type WithdrawResultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    principle: BigNumber;
    tokenInterest: BigNumber;
    forwInterest: BigNumber;
    pTokenBurn: BigNumber;
    atpTokenBurn: BigNumber;
    lossBurn: BigNumber;
    itpTokenBurn: BigNumber;
    ifpTokenBurn: BigNumber;
    tokenInterestBonus: BigNumber;
    forwInterestBonus: BigNumber;
  };
}

export declare namespace PoolToken {
  export type PoolTokensStruct = {
    pToken: BigNumberish;
    atpToken: BigNumberish;
    itpToken: BigNumberish;
    ifpToken: BigNumberish;
  };

  export type PoolTokensStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    pToken: BigNumber;
    atpToken: BigNumber;
    itpToken: BigNumber;
    ifpToken: BigNumber;
  };
}

export interface IAPHPoolInterface extends utils.Interface {
  contractName: "IAPHPool";
  functions: {
    "BLOCK_TIME()": FunctionFragment;
    "activateRank(uint256)": FunctionFragment;
    "addLoss(uint256)": FunctionFragment;
    "atpTokenTotalSupply()": FunctionFragment;
    "balanceAtpTokenOf(uint256)": FunctionFragment;
    "balanceIfpTokenOf(uint256)": FunctionFragment;
    "balanceItpTokenOf(uint256)": FunctionFragment;
    "balancePTokenOf(uint256)": FunctionFragment;
    "borrow(uint256,uint256,uint256,uint256,address)": FunctionFragment;
    "calculateInterest(uint256)": FunctionFragment;
    "claimAllInterest(uint256)": FunctionFragment;
    "claimForwInterest(uint256,uint256)": FunctionFragment;
    "claimTokenInterest(uint256,uint256)": FunctionFragment;
    "coreAddress()": FunctionFragment;
    "currentSupply()": FunctionFragment;
    "deposit(uint256,uint256)": FunctionFragment;
    "forwAddress()": FunctionFragment;
    "getActualTokenPrice()": FunctionFragment;
    "getInterestForwPrice()": FunctionFragment;
    "getInterestTokenPrice()": FunctionFragment;
    "getNextBorrowingInterest(uint256)": FunctionFragment;
    "getRates()": FunctionFragment;
    "getUtils()": FunctionFragment;
    "ifpTokenTotalSupply()": FunctionFragment;
    "interestVaultAddress()": FunctionFragment;
    "itpTokenTotalSupply()": FunctionFragment;
    "lambda()": FunctionFragment;
    "lenders(uint256)": FunctionFragment;
    "loss()": FunctionFragment;
    "membershipAddress()": FunctionFragment;
    "openPosition(uint256,address,address,uint256,uint256,uint256,uint256)": FunctionFragment;
    "pTokenTotalSupply()": FunctionFragment;
    "pause(bytes4)": FunctionFragment;
    "poolBorrowingAddress()": FunctionFragment;
    "poolLendingAddress()": FunctionFragment;
    "rates(uint256)": FunctionFragment;
    "targetSupply()": FunctionFragment;
    "tokenAddress()": FunctionFragment;
    "tokenHolders(uint256)": FunctionFragment;
    "unPause(bytes4)": FunctionFragment;
    "utilizationRate()": FunctionFragment;
    "utils(uint256)": FunctionFragment;
    "utilsLen()": FunctionFragment;
    "withdraw(uint256,uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "BLOCK_TIME",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "activateRank",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLoss",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "atpTokenTotalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "balanceAtpTokenOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceIfpTokenOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceItpTokenOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balancePTokenOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "borrow",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateInterest",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimAllInterest",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimForwInterest",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimTokenInterest",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "coreAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "currentSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "forwAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActualTokenPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInterestForwPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInterestTokenPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNextBorrowingInterest",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "getRates", values?: undefined): string;
  encodeFunctionData(functionFragment: "getUtils", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ifpTokenTotalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "interestVaultAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "itpTokenTotalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "lambda", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lenders",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "loss", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "membershipAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "openPosition",
    values: [
      BigNumberish,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "pTokenTotalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "pause", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "poolBorrowingAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "poolLendingAddress",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rates", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "targetSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenHolders",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "unPause", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "utilizationRate",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "utils", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "utilsLen", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "BLOCK_TIME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "activateRank",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addLoss", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "atpTokenTotalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceAtpTokenOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceIfpTokenOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceItpTokenOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balancePTokenOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimAllInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimForwInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimTokenInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "coreAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forwAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActualTokenPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInterestForwPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInterestTokenPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNextBorrowingInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getRates", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getUtils", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ifpTokenTotalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "interestVaultAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "itpTokenTotalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lambda", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lenders", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "loss", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "membershipAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pTokenTotalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolBorrowingAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "poolLendingAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rates", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "targetSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenHolders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unPause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "utilizationRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "utils", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "utilsLen", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {};
}

export interface IAPHPool extends BaseContract {
  contractName: "IAPHPool";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IAPHPoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BLOCK_TIME(overrides?: CallOverrides): Promise<[BigNumber]>;

    activateRank(
      nftId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLoss(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    atpTokenTotalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    balanceAtpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceIfpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceItpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balancePTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    borrow(
      loanId: BigNumberish,
      nftId: BigNumberish,
      borrowAmount: BigNumberish,
      collateralSentAmount: BigNumberish,
      collateralTokenAddress: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    calculateInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        interestRate: BigNumber;
        interestOwedPerDay: BigNumber;
      }
    >;

    claimAllInterest(
      nftId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claimForwInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claimTokenInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    coreAddress(overrides?: CallOverrides): Promise<[string]>;

    currentSupply(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _currentSupply: BigNumber }>;

    deposit(
      nftId: BigNumberish,
      depositAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    forwAddress(overrides?: CallOverrides): Promise<[string]>;

    getActualTokenPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    getInterestForwPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { ifpPrice: BigNumber }>;

    getInterestTokenPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { itpPrice: BigNumber }>;

    getNextBorrowingInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nextInterestRate: BigNumber }>;

    getRates(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    getUtils(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    ifpTokenTotalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    interestVaultAddress(overrides?: CallOverrides): Promise<[string]>;

    itpTokenTotalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    lambda(overrides?: CallOverrides): Promise<[BigNumber]>;

    lenders(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber]>;

    loss(overrides?: CallOverrides): Promise<[BigNumber]>;

    membershipAddress(overrides?: CallOverrides): Promise<[string]>;

    openPosition(
      nftId: BigNumberish,
      collateralTokenAddress: string,
      swapTokenAddress: string,
      entryPrice: BigNumberish,
      contractSize: BigNumberish,
      leverage: BigNumberish,
      slippage: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    pTokenTotalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    pause(
      _func: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    poolBorrowingAddress(overrides?: CallOverrides): Promise<[string]>;

    poolLendingAddress(overrides?: CallOverrides): Promise<[string]>;

    rates(arg0: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    targetSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    tokenAddress(overrides?: CallOverrides): Promise<[string]>;

    tokenHolders(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[PoolToken.PoolTokensStructOutput]>;

    unPause(
      _func: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    utilizationRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _utilizationRate: BigNumber }>;

    utils(arg0: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    utilsLen(overrides?: CallOverrides): Promise<[BigNumber]>;

    withdraw(
      nftId: BigNumberish,
      withdrawAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

  activateRank(
    nftId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLoss(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  atpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  balanceAtpTokenOf(
    NFTId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceIfpTokenOf(
    NFTId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceItpTokenOf(
    NFTId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balancePTokenOf(
    NFTId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  borrow(
    loanId: BigNumberish,
    nftId: BigNumberish,
    borrowAmount: BigNumberish,
    collateralSentAmount: BigNumberish,
    collateralTokenAddress: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  calculateInterest(
    borrowAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      interestRate: BigNumber;
      interestOwedPerDay: BigNumber;
    }
  >;

  claimAllInterest(
    nftId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claimForwInterest(
    nftId: BigNumberish,
    claimAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claimTokenInterest(
    nftId: BigNumberish,
    claimAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  coreAddress(overrides?: CallOverrides): Promise<string>;

  currentSupply(overrides?: CallOverrides): Promise<BigNumber>;

  deposit(
    nftId: BigNumberish,
    depositAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  forwAddress(overrides?: CallOverrides): Promise<string>;

  getActualTokenPrice(overrides?: CallOverrides): Promise<BigNumber>;

  getInterestForwPrice(overrides?: CallOverrides): Promise<BigNumber>;

  getInterestTokenPrice(overrides?: CallOverrides): Promise<BigNumber>;

  getNextBorrowingInterest(
    borrowAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getRates(overrides?: CallOverrides): Promise<BigNumber[]>;

  getUtils(overrides?: CallOverrides): Promise<BigNumber[]>;

  ifpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  interestVaultAddress(overrides?: CallOverrides): Promise<string>;

  itpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  lambda(overrides?: CallOverrides): Promise<BigNumber>;

  lenders(
    NFTId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[number, BigNumber]>;

  loss(overrides?: CallOverrides): Promise<BigNumber>;

  membershipAddress(overrides?: CallOverrides): Promise<string>;

  openPosition(
    nftId: BigNumberish,
    collateralTokenAddress: string,
    swapTokenAddress: string,
    entryPrice: BigNumberish,
    contractSize: BigNumberish,
    leverage: BigNumberish,
    slippage: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  pTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  pause(
    _func: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  poolBorrowingAddress(overrides?: CallOverrides): Promise<string>;

  poolLendingAddress(overrides?: CallOverrides): Promise<string>;

  rates(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  targetSupply(overrides?: CallOverrides): Promise<BigNumber>;

  tokenAddress(overrides?: CallOverrides): Promise<string>;

  tokenHolders(
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<PoolToken.PoolTokensStructOutput>;

  unPause(
    _func: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

  utils(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  utilsLen(overrides?: CallOverrides): Promise<BigNumber>;

  withdraw(
    nftId: BigNumberish,
    withdrawAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    activateRank(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    addLoss(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    atpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    balanceAtpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceIfpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceItpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balancePTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrow(
      loanId: BigNumberish,
      nftId: BigNumberish,
      borrowAmount: BigNumberish,
      collateralSentAmount: BigNumberish,
      collateralTokenAddress: string,
      overrides?: CallOverrides
    ): Promise<CoreBase.LoanStructOutput>;

    calculateInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        interestRate: BigNumber;
        interestOwedPerDay: BigNumber;
      }
    >;

    claimAllInterest(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PoolBase.WithdrawResultStructOutput>;

    claimForwInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PoolBase.WithdrawResultStructOutput>;

    claimTokenInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PoolBase.WithdrawResultStructOutput>;

    coreAddress(overrides?: CallOverrides): Promise<string>;

    currentSupply(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      nftId: BigNumberish,
      depositAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        mintedP: BigNumber;
        mintedItp: BigNumber;
        mintedIfp: BigNumber;
      }
    >;

    forwAddress(overrides?: CallOverrides): Promise<string>;

    getActualTokenPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getInterestForwPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getInterestTokenPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getNextBorrowingInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRates(overrides?: CallOverrides): Promise<BigNumber[]>;

    getUtils(overrides?: CallOverrides): Promise<BigNumber[]>;

    ifpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    interestVaultAddress(overrides?: CallOverrides): Promise<string>;

    itpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    lambda(overrides?: CallOverrides): Promise<BigNumber>;

    lenders(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber]>;

    loss(overrides?: CallOverrides): Promise<BigNumber>;

    membershipAddress(overrides?: CallOverrides): Promise<string>;

    openPosition(
      nftId: BigNumberish,
      collateralTokenAddress: string,
      swapTokenAddress: string,
      entryPrice: BigNumberish,
      contractSize: BigNumberish,
      leverage: BigNumberish,
      slippage: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    pTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    pause(_func: BytesLike, overrides?: CallOverrides): Promise<void>;

    poolBorrowingAddress(overrides?: CallOverrides): Promise<string>;

    poolLendingAddress(overrides?: CallOverrides): Promise<string>;

    rates(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    targetSupply(overrides?: CallOverrides): Promise<BigNumber>;

    tokenAddress(overrides?: CallOverrides): Promise<string>;

    tokenHolders(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PoolToken.PoolTokensStructOutput>;

    unPause(_func: BytesLike, overrides?: CallOverrides): Promise<void>;

    utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

    utils(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    utilsLen(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      nftId: BigNumberish,
      withdrawAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PoolBase.WithdrawResultStructOutput>;
  };

  filters: {};

  estimateGas: {
    BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    activateRank(
      nftId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLoss(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    atpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    balanceAtpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceIfpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceItpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balancePTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrow(
      loanId: BigNumberish,
      nftId: BigNumberish,
      borrowAmount: BigNumberish,
      collateralSentAmount: BigNumberish,
      collateralTokenAddress: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    calculateInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimAllInterest(
      nftId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claimForwInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claimTokenInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    coreAddress(overrides?: CallOverrides): Promise<BigNumber>;

    currentSupply(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      nftId: BigNumberish,
      depositAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    forwAddress(overrides?: CallOverrides): Promise<BigNumber>;

    getActualTokenPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getInterestForwPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getInterestTokenPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getNextBorrowingInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRates(overrides?: CallOverrides): Promise<BigNumber>;

    getUtils(overrides?: CallOverrides): Promise<BigNumber>;

    ifpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    interestVaultAddress(overrides?: CallOverrides): Promise<BigNumber>;

    itpTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    lambda(overrides?: CallOverrides): Promise<BigNumber>;

    lenders(NFTId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    loss(overrides?: CallOverrides): Promise<BigNumber>;

    membershipAddress(overrides?: CallOverrides): Promise<BigNumber>;

    openPosition(
      nftId: BigNumberish,
      collateralTokenAddress: string,
      swapTokenAddress: string,
      entryPrice: BigNumberish,
      contractSize: BigNumberish,
      leverage: BigNumberish,
      slippage: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    pTokenTotalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    pause(
      _func: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    poolBorrowingAddress(overrides?: CallOverrides): Promise<BigNumber>;

    poolLendingAddress(overrides?: CallOverrides): Promise<BigNumber>;

    rates(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    targetSupply(overrides?: CallOverrides): Promise<BigNumber>;

    tokenAddress(overrides?: CallOverrides): Promise<BigNumber>;

    tokenHolders(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unPause(
      _func: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    utilizationRate(overrides?: CallOverrides): Promise<BigNumber>;

    utils(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    utilsLen(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      nftId: BigNumberish,
      withdrawAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BLOCK_TIME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    activateRank(
      nftId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLoss(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    atpTokenTotalSupply(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceAtpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceIfpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceItpTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balancePTokenOf(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    borrow(
      loanId: BigNumberish,
      nftId: BigNumberish,
      borrowAmount: BigNumberish,
      collateralSentAmount: BigNumberish,
      collateralTokenAddress: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    calculateInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimAllInterest(
      nftId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claimForwInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claimTokenInterest(
      nftId: BigNumberish,
      claimAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    coreAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currentSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      nftId: BigNumberish,
      depositAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    forwAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getActualTokenPrice(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInterestForwPrice(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInterestTokenPrice(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextBorrowingInterest(
      borrowAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRates(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getUtils(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ifpTokenTotalSupply(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    interestVaultAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    itpTokenTotalSupply(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lambda(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lenders(
      NFTId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loss(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    membershipAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    openPosition(
      nftId: BigNumberish,
      collateralTokenAddress: string,
      swapTokenAddress: string,
      entryPrice: BigNumberish,
      contractSize: BigNumberish,
      leverage: BigNumberish,
      slippage: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    pTokenTotalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(
      _func: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    poolBorrowingAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    poolLendingAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rates(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    targetSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenHolders(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unPause(
      _func: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    utilizationRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    utils(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    utilsLen(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      nftId: BigNumberish,
      withdrawAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
